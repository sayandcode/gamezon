{"version":3,"file":"static/js/802.e28090f2.chunk.js","mappings":"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","sources":["utlis/FormHelpers/extendWithFormik.js","components/Address/countryStateCityHelpers.js","components/MuiAutocomplete.js","utlis/FormHelpers/newYupMethods.js","components/Address/AddressFormModal.js"],"sourcesContent":["import { useField } from 'formik';\n\nfunction extendWithFormik(\n  OriginalComponent,\n  { onChangeGivesValue = false } = {}\n) {\n  return function extendedComponent({ helperText, ...restProps }) {\n    const [{ onChange, ...restField }, meta] = useField(restProps);\n\n    /* HANDLE CHANGE */\n    // Formik expects an object of the following shape, which conforms to the event object:\n    // ðŸ‘‰ expectedObj: { target: { id, name, value: 'phoneNumber' } }\n    // to be passed into onChange.\n    // However some components provide the new value, instead of the event object\n    // and hence we handle those by providing the expected object shape to onChange\n    const handleChange = onChangeGivesValue\n      ? (newVal) => {\n          const expectedObj = {\n            target: { id: restProps.id, name: restProps.name, value: newVal },\n          };\n          onChange(expectedObj);\n        }\n      : onChange;\n\n    /* HANDLE ERROR STATES */\n    const error = meta.touched && meta.error;\n    // If there are multiple errors in the form of an object, show each error from object\n    const errorText = isObject(error) ? Object.values(error).join('\\n') : error;\n    // If there is explicit helperText, show it first.\n    // Then on any errors after touched, show the error message\n    const finalHelperText = errorText || helperText;\n\n    return (\n      <OriginalComponent\n        onChange={handleChange}\n        // eslint-disable-next-line react/jsx-props-no-spreading\n        {...restProps}\n        // eslint-disable-next-line react/jsx-props-no-spreading\n        {...restField}\n        error={!!errorText}\n        helperText={finalHelperText}\n      />\n    );\n  };\n}\n\nfunction isObject(obj) {\n  return obj instanceof Object && !(obj instanceof Array);\n}\n\nexport default extendWithFormik;\n","import { City, Country, State } from 'country-state-city';\nimport { string as YupString } from 'yup';\n\n// <benefactor> indicates whether or not the given field has dependants\n// If it does have dependants, then an isoCode is mandatory, since\n// that is what is used to derive the options\nfunction getCscObjShape({ benefactor = true } = {}) {\n  const label = YupString().required('Every Option Should have a label');\n  let isoCode = YupString();\n  if (benefactor)\n    isoCode = isoCode.required(\n      'This field needs an isoCode for its dependants'\n    );\n\n  return { label, isoCode };\n}\n\nfunction getCountryOptions() {\n  const allCountries = Country.getAllCountries();\n  const countryOptions = getOptionsFromCscObjList(allCountries);\n  return countryOptions;\n}\n\nfunction getStateOptions(selectedCountry) {\n  const allStates = State.getStatesOfCountry(selectedCountry?.isoCode);\n  const stateOptions = getOptionsFromCscObjList(allStates);\n  return stateOptions;\n}\n\nfunction getCityOptions(selectedCountry, selectedState) {\n  const allCities = City.getCitiesOfState(\n    selectedCountry?.isoCode,\n    selectedState?.isoCode\n  );\n  const cityOptions = getOptionsFromCscObjList(allCities);\n  return cityOptions;\n}\n\nfunction getOptionsFromCscObjList(cscObjList) {\n  return cscObjList.map((cscObj) => ({\n    label: cscObj.name,\n    isoCode: cscObj.isoCode,\n  }));\n}\n\nexport { getCscObjShape, getCountryOptions, getStateOptions, getCityOptions };\n","import { Autocomplete, TextField } from '@mui/material';\nimport PropTypes from 'prop-types';\n\nfunction MuiAutocomplete({\n  // Value and event handlers\n  value,\n  onChange: handleChange,\n  onBlur,\n  onFocus,\n  // Html and form attributes\n  id,\n  name,\n  label,\n  required,\n  error,\n  helperText,\n  placeholder,\n  options,\n  // Design Attributes\n  disabled,\n  fullWidth,\n  size,\n}) {\n  return (\n    <Autocomplete\n      autoComplete\n      autoHighlight\n      // Value and event handlers\n      {...{\n        value,\n        // give the new option to onChange, as the dom element will not store the options\n        onChange: (event, option) => handleChange(option),\n        onFocus,\n        onBlur,\n      }}\n      // Html and form attributes\n      {...{ id, name, options }}\n      // Design attributes\n      {...{ size, fullWidth, disabled }}\n      renderInput={(params) => {\n        return (\n          <TextField\n            // eslint-disable-next-line react/jsx-props-no-spreading\n            {...params}\n            {...{ required, label, error, helperText, placeholder }}\n            InputLabelProps={{\n              shrink: true,\n              variant: 'standard',\n            }}\n          />\n        );\n      }}\n      isOptionEqualToValue={isOptionEqualToValue}\n    />\n  );\n}\n\nconst optionPropType = PropTypes.oneOfType([\n  PropTypes.string,\n  // eslint-disable-next-line react/forbid-prop-types\n  PropTypes.shape({ label: PropTypes.string }),\n]);\n\nMuiAutocomplete.propTypes = {\n  // Value and event handlers\n  value: optionPropType,\n  onChange: PropTypes.func,\n  onBlur: PropTypes.func,\n  onFocus: PropTypes.func,\n  // Html and form attributes\n  id: PropTypes.string,\n  name: PropTypes.string,\n  label: PropTypes.string,\n  required: PropTypes.bool,\n  error: PropTypes.bool,\n  helperText: PropTypes.string,\n  placeholder: PropTypes.string,\n  options: PropTypes.arrayOf(optionPropType).isRequired,\n  // Design Attributes\n  disabled: PropTypes.bool,\n  fullWidth: PropTypes.bool,\n  size: PropTypes.oneOf(['small', 'medium']),\n};\n\nMuiAutocomplete.defaultProps = {\n  // Value and event handlers\n  value: undefined,\n  onChange: () => {},\n  onBlur: () => {},\n  onFocus: () => {},\n  // Html and form attributes\n  id: undefined,\n  name: undefined,\n  label: undefined,\n  required: false,\n  error: false,\n  helperText: '',\n  placeholder: '',\n  // Design Attributes\n  disabled: false,\n  fullWidth: false,\n  size: 'medium',\n};\n\n// If the options are strings, then Mui handles it automatically.\n// So there is no need for this ðŸ‘‡ function to be overloaded.\nexport function isOptionEqualToValue(option, value) {\n  return option.label === value.label;\n}\n\nexport default MuiAutocomplete;\n","import { addMethod, object, string } from 'yup';\nimport { isPossiblePhoneNumber } from 'react-phone-number-input';\nimport { isOptionEqualToValue as isOptionEqualToSelectedOption } from '../../components/MuiAutocomplete';\n\n/* Yup's schema validation for Autocomplete */\naddMethod(\n  object,\n  'isFromOptionsProvidedBy',\n  function isFromOptionsProvidedBy(\n    optionProvidingFields,\n    optionProvidingFn,\n    {\n      // eslint-disable-next-line no-template-curly-in-string\n      errorMessage = 'That is not a valid ${path}',\n\n      // <required> option is slightly different in autocomplete. There is no point of a required, if there are no options.\n      // So this appends the .nullable() to the test, and handles this case manually inside the test fn.\n      // The internal required check only works if there are options to be added.\n      required,\n    } = {}\n  ) {\n    return object()\n      .test({\n        name: 'isValidOption',\n        test(selectedOption) {\n          const { path, parent, createError } = this;\n          const dependencies = optionProvidingFields.map(\n            (field) => parent[field]\n          );\n          const options = optionProvidingFn(...dependencies);\n\n          /* CALCULATE DATA TO BE USED */\n          const thereAreNoOptions = options.length === 0;\n          // <required> is polymorphic. It can either be true, or carry the string to show when required, which itself\n          // indicates that required is true. For the first case, we specify a default message.\n          const requiredMessage =\n            // eslint-disable-next-line no-template-curly-in-string\n            required === true ? '${path} cannot be empty' : required;\n\n          /* HANDLE CASES */\n          // Case 1: No options are possible, and we have no selectedOption\n          if (thereAreNoOptions && !selectedOption) return true;\n          // Case 2: Options are possible, and we have no selected option, and the field is required\n          if (!selectedOption && requiredMessage)\n            return createError({ path, message: requiredMessage });\n          // ALL OTHER CASES: i.e. when options are provided, and an option(dk if selected from possible ones) is selected\n          // Here, <required> check is immaterial, as an option is selected.\n          const optionsHasSelectedOption = options.find((option) =>\n            isOptionEqualToSelectedOption(option, selectedOption)\n          );\n          return (\n            optionsHasSelectedOption ||\n            createError({ path, message: errorMessage })\n          );\n        },\n      })\n      .nullable();\n  }\n);\n\n/* Yup's schema validation for Phone Number */\naddMethod(\n  string,\n  'isPossiblePhoneNumber',\n  function validatePhoneNumber(errorMessage) {\n    return this.test('is-a-phone-number', function testForPhoneNumber(value) {\n      // For empty values, we allow the validation to happen externally, via .nullable() and .required()\n      if (!value) return true;\n\n      const { path, createError } = this;\n\n      return (\n        isPossiblePhoneNumber(value) ||\n        createError({ path, message: errorMessage })\n      );\n    });\n  }\n);\n","import { Close } from '@mui/icons-material';\nimport {\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogTitle,\n  IconButton,\n  Stack,\n  TextField,\n} from '@mui/material';\nimport PropTypes from 'prop-types';\nimport { Formik, Form } from 'formik';\nimport { object as YupObject, string as YupString } from 'yup';\nimport { useContext } from 'react';\nimport extendWithFormik from '../../utlis/FormHelpers/extendWithFormik';\nimport MuiPhoneNumberInput from '../MuiPhoneNumberInput';\nimport {\n  getCscObjShape,\n  getCityOptions,\n  getCountryOptions,\n  getStateOptions,\n} from './countryStateCityHelpers';\nimport MuiAutocomplete from '../MuiAutocomplete';\nimport { UserContext } from '../../utlis/Contexts/UserData/UserContext';\nimport '../../utlis/FormHelpers/newYupMethods';\nimport Address from '../../utlis/Contexts/UserData/UserDataHelperClasses/AddressList/AddressClass';\n\nconst FormikTextField = extendWithFormik(TextField);\nconst FormikAutocomplete = extendWithFormik(MuiAutocomplete, {\n  onChangeGivesValue: true,\n});\nconst FormikPhoneNumber = extendWithFormik(MuiPhoneNumberInput, {\n  onChangeGivesValue: true,\n});\n\nconst defaultInitialFormValues = {\n  firstName: '',\n  lastName: '',\n  addressLine1: '',\n  addressLine2: '',\n  country: null,\n  state: null,\n  city: null,\n  phoneNumber: '',\n};\n\n/* NOTE: Validation schema is statically set at the beginning. */\n/* The only dynamic control we have is in the test and addMethod(which is a wrapper) */\nconst validationSchema = YupObject({\n  firstName: YupString().required(\"Can't be empty\"),\n  lastName: YupString().required(\"Can't be empty\"),\n  addressLine1: YupString().required('Where will we deliver?'),\n  addressLine2: YupString(),\n  country: YupObject(getCscObjShape())\n    .nullable()\n    .required(\"Country can't be empty\"),\n\n  state: YupObject()\n    .isFromOptionsProvidedBy(['country'], getStateOptions, {\n      required: 'State cannot be empty',\n    })\n    .shape(getCscObjShape()),\n  city: YupObject()\n    .isFromOptionsProvidedBy(['country', 'state'], getCityOptions, {\n      required: 'City cannot be empty',\n    })\n    .shape(getCscObjShape({ benefactor: false })),\n  phoneNumber: YupString()\n    .isPossiblePhoneNumber('Enter a valid phone number')\n    .required('How will we call you?'),\n});\n\nconst placeholders = {\n  firstName: 'Dwight',\n  lastName: 'Schrute',\n  addressLine1: 'Dunder Mifflin Scranton, Scranton Business Park',\n  addressLine2: '1725 Slough Avenue, Scranton',\n  country: 'United States',\n  state: 'Pennsylvania',\n  city: 'Scranton',\n  phoneNumber: '+1 570 343 3400',\n};\n\nfunction AddressFormModal({\n  open,\n  onClose: handleClose,\n  edit: addressToBeEdited,\n}) {\n  const { addressList } = useContext(UserContext);\n\n  // If the edit prop is passed with an Address, then fetch the initial value of the form from it.\n  const initialFormValues =\n    addressToBeEdited?.content || defaultInitialFormValues;\n\n  const dialogTitleText = addressToBeEdited\n    ? 'Edit address'\n    : 'Add new address';\n\n  const handleSubmit = (formValues) => {\n    const newAddress = new Address(formValues);\n    if (addressToBeEdited) addressList.edit(addressToBeEdited, newAddress);\n    else addressList.add(newAddress);\n    handleClose();\n  };\n\n  return (\n    <Dialog\n      open={open}\n      onClose={handleClose}\n      PaperProps={{ sx: { p: 1, bgcolor: 'grey.200', position: 'relative' } }}\n    >\n      <Formik\n        initialValues={initialFormValues}\n        validationSchema={validationSchema}\n        onSubmit={handleSubmit}\n      >\n        {({ values: formValues, setFieldValue }) => {\n          const selectedCountry = formValues.country;\n          const selectedState = formValues.state;\n          const selectedCity = formValues.city;\n\n          const countryOptions = getCountryOptions();\n          const stateOptions = getStateOptions(selectedCountry);\n          const cityOptions = getCityOptions(selectedCountry, selectedState);\n\n          /* HANDLE BACKTRACKING ERRORS  */\n          // Sometimes the user selects an option, and then goes back to edit a previous field, rendering\n          // the selected option invalid. So every time this happens, programmatically set the field to null,\n          if (selectedState !== null && stateOptions.length === 0)\n            setFieldValue('state', null);\n          if (selectedCity !== null && cityOptions.length === 0)\n            setFieldValue('city', null);\n\n          return (\n            <Form>\n              <DialogTitle>{dialogTitleText}</DialogTitle>\n              <IconButton\n                sx={{\n                  position: 'absolute',\n                  top: (theme) => theme.spacing(2),\n                  right: (theme) => theme.spacing(2),\n                }}\n                onClick={handleClose}\n              >\n                <Close />\n              </IconButton>\n              <DialogContent>\n                <Stack direction=\"row\" spacing={2}>\n                  <FormikTextField\n                    label=\"First Name\"\n                    id=\"firstName\"\n                    name=\"firstName\"\n                    size=\"small\"\n                    fullWidth\n                    placeholder={placeholders.firstName}\n                  />\n                  <FormikTextField\n                    label=\"Last Name\"\n                    id=\"lastName\"\n                    name=\"lastName\"\n                    placeholder={placeholders.lastName}\n                    fullWidth\n                    size=\"small\"\n                  />\n                </Stack>\n                <FormikTextField\n                  label=\"Address Line 1\"\n                  id=\"addressLine1\"\n                  name=\"addressLine1\"\n                  placeholder={placeholders.addressLine1}\n                  size=\"small\"\n                  fullWidth\n                />\n                <FormikTextField\n                  label=\"Address Line 2\"\n                  id=\"addressLine2\"\n                  name=\"addressLine2\"\n                  placeholder={placeholders.addressLine2}\n                  size=\"small\"\n                  fullWidth\n                />\n\n                <Stack direction=\"row\" spacing={2}>\n                  <FormikAutocomplete\n                    id=\"country\"\n                    name=\"country\"\n                    placeholder={placeholders.country}\n                    label=\"Country\"\n                    options={countryOptions}\n                    fullWidth\n                    size=\"small\"\n                  />\n                  <FormikAutocomplete\n                    id=\"state\"\n                    name=\"state\"\n                    placeholder={placeholders.state}\n                    label=\"State\"\n                    disabled={!selectedCountry || stateOptions.length === 0}\n                    options={stateOptions}\n                    size=\"small\"\n                    fullWidth\n                  />\n                </Stack>\n                <Stack direction=\"row\" spacing={2}>\n                  <FormikAutocomplete\n                    id=\"city\"\n                    name=\"city\"\n                    placeholder={placeholders.city}\n                    label=\"City\"\n                    disabled={!selectedState}\n                    options={cityOptions}\n                    size=\"small\"\n                    fullWidth\n                  />\n                  <FormikPhoneNumber\n                    id=\"phoneNumber\"\n                    name=\"phoneNumber\"\n                    placeholder={placeholders.phoneNumber}\n                    label=\"Phone Number\"\n                    size=\"small\"\n                    fullWidth\n                  />\n                </Stack>\n              </DialogContent>\n              <DialogActions>\n                <Button variant=\"contained\" type=\"submit\">\n                  Submit\n                </Button>\n                <Button variant=\"outlined\" onClick={handleClose}>\n                  Cancel\n                </Button>\n              </DialogActions>\n            </Form>\n          );\n        }}\n      </Formik>\n    </Dialog>\n  );\n}\n\nAddressFormModal.propTypes = {\n  open: PropTypes.bool,\n  onClose: PropTypes.func,\n  edit: PropTypes.instanceOf(Address),\n};\n\nAddressFormModal.defaultProps = {\n  open: false,\n  onClose: () => {},\n  edit: undefined,\n};\n\nexport default AddressFormModal;\n"],"names":["isObject","obj","Object","Array","OriginalComponent","onChangeGivesValue","helperText","restProps","useField","onChange","restField","meta","handleChange","newVal","expectedObj","target","id","name","value","error","touched","errorText","values","join","finalHelperText","getCscObjShape","benefactor","label","YupString","required","isoCode","getStateOptions","selectedCountry","getOptionsFromCscObjList","State","getCityOptions","selectedState","City","cscObjList","map","cscObj","MuiAutocomplete","onBlur","onFocus","placeholder","options","disabled","fullWidth","size","Autocomplete","autoComplete","autoHighlight","event","option","renderInput","params","TextField","InputLabelProps","shrink","variant","isOptionEqualToValue","defaultProps","undefined","addMethod","object","optionProvidingFields","optionProvidingFn","errorMessage","test","selectedOption","path","this","parent","createError","dependencies","field","thereAreNoOptions","length","requiredMessage","message","find","isOptionEqualToSelectedOption","nullable","string","isPossiblePhoneNumber","FormikTextField","extendWithFormik","FormikAutocomplete","FormikPhoneNumber","MuiPhoneNumberInput","defaultInitialFormValues","firstName","lastName","addressLine1","addressLine2","country","state","city","phoneNumber","validationSchema","YupObject","isFromOptionsProvidedBy","shape","placeholders","AddressFormModal","open","handleClose","onClose","addressToBeEdited","edit","addressList","useContext","UserContext","initialFormValues","content","dialogTitleText","Dialog","PaperProps","sx","p","bgcolor","position","initialValues","onSubmit","formValues","newAddress","Address","add","setFieldValue","selectedCity","countryOptions","Country","stateOptions","cityOptions","DialogTitle","IconButton","top","theme","spacing","right","onClick","Close","DialogContent","Stack","direction","DialogActions","Button","type"],"sourceRoot":""}